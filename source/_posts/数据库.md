---
title: 数据库
tags:
  - 复习
categories: 数据库
hide: true
abbrlink: 63394
date: 2021-04-17 23:42:10
---

# 数据库

### 题目

一个数据模型至少需要描述数据的静态特征、动态特征和（ **完整性约束** ）三项内容。



(**DB** )是长期存储在计算机内的有组织、可共享的数据集合。 



关于关系，下列说法中正确的是
**Ⅰ.关系中的每一个属性都是不可再分解的**
**Ⅱ.关系中不允许出现取值完全相同的元组**
**Ⅲ.可以不考虑关系中各元组的顺序**
**Ⅳ.可以不考虑关系中各属性的顺序**



对现实世界进行第一层抽象的模型，称为（）模型；对现实世界进行第二层抽象的模型，称为（）模型。 **概念，结构/逻辑**



在E-R图中，用来表示属性的图形是（    ） **椭圆形** 



SQL语言中用（ **rollback**）语句实现事务的回滚

触发器是一种特殊类型的存储过程，它不同于存储过程。



视图和表不一样，不是在物理上存在的一种数据库对象。



在SQL语言中的视图VIEW是数据库的（ **外模式**） 。

下列关于关系数据库的操作特点的说法，正确的是
    A. 需要指明操作的要求和操作的实现过程
    **B. 需要指明操作的要求，但不需要指明操作的实现过程    √**
    C. 需要指明操作的实现过程，但不需要指明操作的要求
    D. 对操作要求和操作实现过程都不需要指明



下述对出生日期进行比较的表达式中，正确的是
    A. 出生日期 >‘1980/1/1’



从一个表中筛选数据向另一个已经存在的表添加所用的命令是（ **INSERT…SELECT**    ）。



若要在基本表中增加一列CN（课程名），可用（ **alter table s add (cn char(8))** ）



查找表结构用以下哪一项（  **DESC**）



 在SQL Server中，在表中添加一个新列的正确SQL语句是 **B. ALTER TABLE ADD 新列名 数据类型**



数据类型Numeric(10,4)表示的数据是 **小数点后边有4位数字，小数点前边有6位数字**



TRUNCATE TABLE相当于无条件的DELETE FROM



数据库的( **完整性**)是 指数据的正确性和相容性。



数据模型的三要素是**数据结构、数据操作和数据完整性约束**



数据模型的三要素  **数据结构 ，完整性约束，数据操纵**



二维表结构是**关系数据库采用的组织层数据模型**



文件系统具有的数据独立性是(.**设备独立性** )。











































### 概念

```
事务
	（1）原子性：整个事务中的所有操作，要么全部完成，要么全部不完成，不可能停滞在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。
   （2）一致性：在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。
   （3）隔离性：隔离状态执行事务，使它们好像是系统在给定时间内执行的唯一操作。如果有两个事务，运行在相同的时间内，执行 相同的功能，事务的隔离性将确保每一事务在系统中认为只有该事务在使用系统。这种属性有时称为串行化，为了防止事务操作间的混淆，  必须串行化或序列化请 求，使得在同一时间仅有一个请求用于同一数据。
   （4）持久性：在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。

删除操作
drop:
	视图，表table,列column
delete
	
```



1. from 
2. join 
3. on 
4. where 
5. group by(开始使用select中的别名，后面的语句中都可以使用)
6.  avg,sum.... 
7. having 
8. select 
9. distinct 
10. order by
11. limit 
    从这个顺序中我们不难发现，所有的 查询语句都是从from开始执行的，在执行过程中，每个步骤都会为下一个步骤生成一个虚拟表，这个虚拟表将作为下一个执行步骤的输入。 


**第一步：**首先对from子句中的前两个表执行一个笛卡尔乘积，此时生成虚拟表 vt1（选择相对小的表做基础表）。 
**第二步：**接下来便是应用on筛选器，on 中的逻辑表达式将应用到 vt1 中的各个行，筛选出满足on逻辑表达式的行，生成虚拟表 vt2 。
**第三步：**如果是outer join 那么这一步就将添加外部行，left outer jion 就把左表在第二步中过滤的添加进来，如果是right outer join 那么就将右表在第二步中过滤掉的行添加进来，这样生成虚拟表 vt3 。

**第四步：**如果 from 子句中的表数目多余两个表，那么就将vt3和第三个表连接从而计算笛卡尔乘积，生成虚拟表，该过程就是一个重复1-3的步骤，最终得到一个新的虚拟表 vt3。 

**第五步：**应用where筛选器，对上一步生产的虚拟表引用where筛选器，生成虚拟表vt4，在这有个比较重要的细节不得不说一下，对于包含outer join子句的查询，就有一个让人感到困惑的问题，到底在on筛选器还是用where筛选器指定逻辑表达式呢？on和where的最大区别在于，如果在on应用逻辑表达式那么在第三步outer join中还可以把移除的行再次添加回来，而where的移除的最终的。举个简单的例子，有一个学生表（班级,姓名）和一个成绩表(姓名,成绩)，我现在需要返回一个x班级的全体同学的成绩，但是这个班级有几个学生缺考，也就是说在成绩表中没有记录。为了得到我们预期的结果我们就需要在on子句指定学生和成绩表的关系（学生.姓名=成绩.姓名）那么我们是否发现在执行第二步的时候，对于没有参加考试的学生记录就不会出现在vt2中，因为他们被on的逻辑表达式过滤掉了,但是我们用left outer join就可以把左表（学生）中没有参加考试的学生找回来，因为我们想返回的是x班级的所有学生，如果在on中应用学生.班级='x'的话，left outer join会把x班级的所有学生记录找回（感谢网友康钦谋__康钦苗的指正），所以只能在where筛选器中应用学生.班级='x' 因为它的过滤是最终的。 

**第六步：**group by 子句将中的唯一的值组合成为一组，得到虚拟表vt5。如果应用了group by，那么后面的所有步骤都只能得到的vt5的列或者是聚合函数（count、sum、avg等）。原因在于最终的结果集中只为每个组包含一行。这一点请牢记。 

**第七步：**应用cube或者rollup选项，为vt5生成超组，生成vt6. 
**第八步：**应用having筛选器，生成vt7。having筛选器是第一个也是为唯一一个应用到已分组数据的筛选器。 
**第九步：**处理select子句。将vt7中的在select中出现的列筛选出来。生成vt8. 

**第十步：**应用distinct子句，vt8中移除相同的行，生成vt9。事实上如果应用了group by子句那么distinct是多余的，原因同样在于，分组的时候是将列中唯一的值分成一组，同时只为每一组返回一行记录，那么所以的记录都将是不相同的。 

**第十一步：**应用order by子句。按照order_by_condition排序vt9，此时返回的一个游标，而不是虚拟表。sql是基于集合的理论的，集合不会预先对他的行排序，它只是成员的逻辑集合，成员的顺序是无关紧要的。对表进行排序的查询可以返回一个对象，这个对象包含特定的物理顺序的逻辑组织。这个对象就叫游标。正因为返回值是游标，那么使用order by 子句查询不能应用于表表达式。排序是很需要成本的，除非你必须要排序，否则最好不要指定order by，最后，在这一步中是第一个也是唯一一个可以使用select列表中别名的步骤。 

**第十二步：**应用top选项。此时才返回结果给请求者即用户。 



### 一些语句

```sql
between 30 and 40


case
when 订单状态='1' then '等待出库'
when 订单状态='2' then '已发货'
when 订单状态='3' then '已完成'
end


substring(姓名,1,1)		//从第1个字符开始 只截取之后的1个字符



select distinct 城市		//去重复
from 购物者


create proc prc_score
@sno char(10)
as
begin
select sname as 姓名,avg(grade) as 平均分数
from S,SC
where s.sno=sc.sno
and s.sno=@sno
group by sname
end

exists!!!
if not exists(select * from tuser where uid=@uid)
select '-1'
else
if not exists(select * from tuser where upwd=@upwd)
select '-2'
   else
     select   '0'




```